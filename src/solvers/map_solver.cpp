#include "solvers/map_solver.h"

#include <iostream>
#include <vector>

#include "image/image_data.h"
#include "solvers/map_cost_function.h"

#include "opencv2/core/core.hpp"

#include "ceres/ceres.h"

namespace super_resolution {

// Applies the given ImageModel to the given estimated high-resolution image to
// generate a set of low-resolution images as observation estimates. These LR
// images generated by the given image formation model are used to solve the
// MAP objective. The generated LR images will be resized to the size of the
// given HR estimate.
//
// The LR estimates will be added to the given observation_estimates vector.
// This vector will be emptied before the new estimates are inserted.
void GetObservationEstimates(
    const ImageData& estimated_image,
    const ImageModel& image_model,
    const int num_images,
    std::vector<ImageData>* observation_estimates) {

  const cv::Size image_size = estimated_image.GetImageSize();

  observation_estimates->clear();
  for (int i = 0; i < num_images; ++i) {
    ImageData low_res_estimate = image_model.ApplyModel(estimated_image, i);
    low_res_estimate.ResizeImage(image_size, cv::INTER_AREA);
    observation_estimates->push_back(low_res_estimate);
  }
}

// Callback object for the solver. After every iteration, applies the model to
// the estimated HR image to generate the LR estimates given the image
// formation model. These LR estimates are used to optimize for the new HR
// estimate in the next iteration.
class ApplyModelCallback : public ceres::IterationCallback {
 public:
  ApplyModelCallback(
      const ImageData* estimated_image,
      const ImageModel& image_model,
      const int num_observations,
      std::vector<ImageData>* observation_estimates)
      : estimated_image_(estimated_image),
        image_model_(image_model),
        num_observations_(num_observations),
        observation_estimates_(observation_estimates) {}

  // Called after each iteration, generates the LR observation estimates for
  // the next iteration.
  ceres::CallbackReturnType operator() (
      const ceres::IterationSummary& summary) {
    GetObservationEstimates(
        *estimated_image_,
        image_model_,
        num_observations_,
        observation_estimates_);
    return ceres::SOLVER_CONTINUE;
  }

 private:
  // The estimated image gets updated by the solver at each iteration.
  const ImageData* estimated_image_;

  // The image model is used to generate the LR observation estimates and does
  // not change.
  const ImageModel& image_model_;

  // The LR observation estimates are generated after (before) every iteration
  // to be used for the next iteration.
  const int num_observations_;
  std::vector<ImageData>* observation_estimates_;
};

ImageData MapSolver::Solve(const ImageData& initial_estimate) const {
  const int num_observations = low_res_images_.size();
  CHECK(num_observations > 0) << "Cannot solve with 0 low-res images.";

  ImageData estimated_image = initial_estimate;
  const cv::Size image_size = initial_estimate.GetImageSize();

  // Upsample all of the observed low-resolution images to the size of the
  // high-resolution image so we can compare pixels directly.
  std::vector<ImageData> observations;
  for (const ImageData& low_res_image : low_res_images_) {
    ImageData observation = low_res_image;
    observation.ResizeImage(image_size, cv::INTER_AREA);
    observations.push_back(observation);
  }

  std::vector<ImageData> observation_estimates;
  GetObservationEstimates(
      estimated_image, image_model_, num_observations, &observation_estimates);

  // 3. (r) Initialize w_i = 1.

  // 4. Iterate:
  //    a. set est. ^Y_k = image_model_.ApplyModel(X) in low_res_predictions
  //    b. run data term LS between every pixel i of Y_k(i) and X(i)
  //    c. (r) compute regularization at every pixel in estimated X
  //        THIS NEEDS TO BE DONE right after data fidelity estimate is
  //        computed because the regularization is applied to those changes.
  //        Right when regularization is computed, simultaneously compute the
  //        weight w_i.
  //        >>> It might be worth doing this in the regularization cost
  //            function directly.

  // 2. For each frame, apply the image model and naively scale it up to the
  // size of the HR image.
  // TODO: what type of interpolation to use for the scaling? cv::INTER_AREA?
  // TODO: implement this is a callback function/object.
  const int num_frames = low_res_images_.size();
  std::vector<ImageData> low_res_predictions;
  for (int i = 0; i < num_frames; ++i) {
    low_res_predictions.push_back(image_model_.ApplyModel(estimated_image, i));
    // TODO: rescale all of these LR predictions to match the HR size.
  }

  const int num_channels = low_res_images_[0].GetNumChannels();
  const int num_images = low_res_images_.size();
  const int num_pixels = low_res_images_[0].GetNumPixels();

  ceres::Problem problem;
  // TODO: currently solves independently for each channel.
  for (int channel_index = 0; channel_index < num_channels; ++channel_index) {
    for (int image_index = 0; image_index < num_images; ++image_index) {
      for (int pixel_index = 0; pixel_index < num_pixels; ++pixel_index) {
        ceres::CostFunction* cost_function = MapCostFunction::Create(
            &low_res_predictions, image_index, channel_index, pixel_index);
        problem.AddResidualBlock(
            cost_function,
            NULL,  // basic loss
            estimated_image.GetMutableDataPointer(channel_index, pixel_index));
      }
    }
  }

  // TODO: handle regularization.

  // Set the solver options. TODO: figure out what these should be.
  ceres::Solver::Options options;
  // options.linear_solver_type = ceres::DENSE_SCHUR;
  // Always update parameters because we need to compute the new LR estimates.
  options.update_state_every_iteration = true;
  options.minimizer_progress_to_stdout = true;

  // Solve.
  ceres::Solver::Summary summary;
  ceres::Solve(options, &problem, &summary);
  std::cout << summary.FullReport() << std::endl;

  return estimated_image;
}

}  // namespace super_resolution
